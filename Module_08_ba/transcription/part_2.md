# Конспект лекции: Базы данных, SQL и AI-агенты в VS Code

**Участники:** Преподаватель (Николай), Студенты (Ольга, Татьяна).  
**Инструменты:** VS Code, расширение Antigravity (или KiloCode), SQLite Viewer.

## Часть 1. Введение и настройка окружения

**Задача:** Создать тестовую базу данных и посмотреть, как она устроена «под капотом».  
**Инструмент:** Используется AI-агент внутри VS Code для генерации кода.

- **Установка:** Необходимо установить расширение SQLite Viewer в VS Code, чтобы визуально просматривать файлы баз данных.
    
- **Концепция:** SQL (Structured Query Language) — язык, позволяющий делать с данными всё что угодно. Раньше базы данных работали только через него.
    

## Часть 2. Проектирование схемы Базы Данных (БД)

Преподаватель просит AI-агента создать скрипт для учебной базы данных.

**Структура таблиц (Схема):**

1. **Students (Студенты):**
    
    - id: Целое число, первичный ключ (Primary Key), автоинкремент (сам увеличивается на +1).
        
    - first_name, last_name: Текст, не может быть пустым (NOT NULL).
        
    - email: Уникальный (UNIQUE). Нельзя создать двух студентов с одинаковой почтой.
        
    - created_at: Служебное поле, дата создания записи.
        
2. **Teachers (Преподаватели):** Имя, контакты, специализация.
    
3. **Courses (Курсы):** Название, описание, длительность.
    
    - Связь: Привязка к teacher_id. Упрощение модели: один курс ведет один преподаватель.
        
4. **Groups (Группы):**
    
    - Связывается с курсом (course_id).
        
    - Целостность данных: нельзя создать группу, которая не ссылается на существующий курс.
        

**Действие:** Запуск скрипта. Создается файл school.db. Через SQLite Viewer видно пустые таблицы.

## Часть 3. Наполнение данными (Mock Data)

**Проблема:** Вручную заполнять таблицы долго.  
**Решение:** Попросить AI-агента сгенерировать тестовые данные (faker).

- Агент пишет SQL-команды INSERT INTO....
    
- Заполняются студенты, преподаватели, курсы (например, «Матан»).
    
- Формируются группы.
    

## Часть 4. Работа с данными: SQL-запросы

Нужно извлечь информацию из базы. Вместо ручного перебора используются запросы.

**Задача:** Найти группу, в которой больше всего учеников.  
**Код (примерный смысл):**

codeSQL

```
SELECT group_name, COUNT(student_id)
FROM students
JOIN groups ON students.group_id = groups.id
GROUP BY group_name
ORDER BY count DESC
LIMIT 1;
```

**Результат:** Агент выдал SQL-запрос, который сразу показал нужную группу. Это демонстрирует мощь SQL: одной строкой можно проанализировать огромный массив данных.

## Часть 5. Миграция реальных данных (CSV)

**Сценарий:** Есть старый файл students.csv (выгрузка из Excel/Google Sheets), нужно перенести его в новую базу данных.  
**Формат CSV:** Comma Separated Values (значения, разделенные запятыми).

**Проблемы при импорте (из диалога):**

1. **Грязные данные:** Даты в разных форматах, имена написаны как попало, лишние пробелы.
    
2. **Структура:** В CSV всё одной строкой (Имя, Группа, Город), а в БД это должны быть разные таблицы, связанные ID.
    
3. **Логика:**
    
    - Если города нет в базе справочников — создать.
        
    - Если группа не существует — создать.
        
    - Потом привязать студента к этой группе.
        

**Решение:**

- Написать скрипт на Python для парсинга CSV.
    
- Использовать AI для написания этого скрипта (промпт: "Прочитай файл CSV и мигрируй данные в SQLite, разложив по таблицам").
    
- **Отладка:** С первого раза скрипт не сработал (ошибки с датами, кодировкой). Приходится просить агента исправить ошибки («Я ничего не понимаю, объясни как для ребенка», «Исправь скрипт»).
    

## Часть 6. Архитектурные сложности (Many-to-Many)

В ходе обсуждения выяснилось, что упрощенная схема (Студент -> Группа) не работает в реальности.

- **Проблема:** Студент может учиться сначала в одной группе, потом перейти в другую. Или учиться на двух курсах одновременно.
    
- **Решение:** Нужна таблица-связка Enrollments (Зачисления).
    
    - Она хранит: student_id, group_id, start_date, end_date, status (активен/отчислен).
        
- Это позволяет хранить историю обучения.
    

## Часть 7. Философский блок: "Зачем нам это, если есть Excel?"

Самая эмоциональная часть лекции.

**Ольга (Скептик):** Зачем всё это усложнение? Я хочу нажать одну кнопку, и чтобы моя SMM-стратегия по 10 проектам сама делалась. А тут мы ковыряем таблицы вручную.  
**Преподаватель (Ответ):**

1. **Нельзя съесть слона целиком.** Нельзя сразу построить "Звезду Смерти" (идеальную автоматизацию).
    
2. **MVP (Minimal Viable Product):** Сначала делаем полу-автоматический режим. Руками собираем данные, но храним их правильно. Потом автоматизируем один кусочек (например, создание постов). Потом другой.
    
3. **Роль человека:** Вы (Ольга) — архитектор. Агент (AI) — исполнитель. Вы должны понимать, как это работает, чтобы ставить задачу. Если вы не знаете, как устроена база, вы не сможете объяснить агенту, как её заполнить.
    
4. **Реальность:** Никто не даст вам гарантию, что кнопка "Сделать всё хорошо" сработает идеально сразу. Нужно проходить путь итерациями.
    

## Ключевые выводы урока:

1. **База данных vs Таблица:** БД обеспечивает целостность (нельзя удалить курс, если на нем учатся студенты) и позволяет делать сложные выборки.
    
2. **AI как помощник:** Он пишет код (SQL, Python) быстрее нас, но ему нужно четко ставить задачу (промптинг).
    
3. **Отладка неизбежна:** Даже с AI код падает с ошибками. Нужно читать логи (консоль), копировать ошибку агенту и просить исправить.
    
4. **Путь автоматизации:** Ручной труд -> Структурирование данных -> Скрипты-помощники -> Полная автоматизация. Нельзя перепрыгнуть сразу в конец.